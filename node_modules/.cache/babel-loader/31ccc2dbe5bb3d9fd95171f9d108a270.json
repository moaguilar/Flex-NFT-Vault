{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst tslib_1 = require(\"tslib\");\n\nconst crypto_1 = tslib_1.__importDefault(require(\"crypto\"));\n\nconst utils_1 = require(\"@walletconnect/utils\");\n\nconst AES_ALGORITHM = \"AES-256-CBC\";\nconst HMAC_ALGORITHM = \"SHA256\";\n\nfunction randomBytes(length) {\n  return new Promise((resolve, reject) => {\n    crypto_1.default.randomBytes(length, (error, result) => {\n      if (error) {\n        reject(error);\n      }\n\n      resolve(result);\n    });\n  });\n}\n\nexports.randomBytes = randomBytes;\n\nfunction generateKey(length) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    const _length = (length || 256) / 8;\n\n    const buffer = yield randomBytes(_length);\n    const hex = utils_1.convertBufferToHex(buffer, true);\n    const result = utils_1.convertHexToArrayBuffer(hex);\n    return result;\n  });\n}\n\nexports.generateKey = generateKey;\n\nfunction createHmac(data, key) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    const hmac = crypto_1.default.createHmac(HMAC_ALGORITHM, key);\n    hmac.update(data);\n    const hex = hmac.digest(\"hex\");\n    const result = utils_1.convertHexToBuffer(hex);\n    return result;\n  });\n}\n\nexports.createHmac = createHmac;\n\nfunction verifyHmac(payload, key) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    const cipherText = utils_1.convertHexToBuffer(payload.data);\n    const iv = utils_1.convertHexToBuffer(payload.iv);\n    const hmac = utils_1.convertHexToBuffer(payload.hmac);\n    const hmacHex = utils_1.convertBufferToHex(hmac, true);\n    const unsigned = utils_1.concatBuffers(cipherText, iv);\n    const chmac = yield createHmac(unsigned, key);\n    const chmacHex = utils_1.convertBufferToHex(chmac, true);\n\n    if (utils_1.removeHexPrefix(hmacHex) === utils_1.removeHexPrefix(chmacHex)) {\n      return true;\n    }\n\n    return false;\n  });\n}\n\nexports.verifyHmac = verifyHmac;\n\nfunction aesCbcEncrypt(data, key, iv) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    const cipher = crypto_1.default.createCipheriv(AES_ALGORITHM, key, iv);\n    const result = utils_1.concatBuffers(cipher.update(data), cipher.final());\n    return result;\n  });\n}\n\nexports.aesCbcEncrypt = aesCbcEncrypt;\n\nfunction aesCbcDecrypt(data, key, iv) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    const decipher = crypto_1.default.createDecipheriv(AES_ALGORITHM, key, iv);\n    const result = utils_1.concatBuffers(decipher.update(data), decipher.final());\n    return result;\n  });\n}\n\nexports.aesCbcDecrypt = aesCbcDecrypt;\n\nfunction encrypt(data, key, providedIv) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    const _key = utils_1.convertArrayBufferToBuffer(key);\n\n    const ivArrayBuffer = providedIv || (yield generateKey(128));\n    const iv = utils_1.convertArrayBufferToBuffer(ivArrayBuffer);\n    const ivHex = utils_1.convertBufferToHex(iv, true);\n    const contentString = JSON.stringify(data);\n    const content = utils_1.convertUtf8ToBuffer(contentString);\n    const cipherText = yield aesCbcEncrypt(content, _key, iv);\n    const cipherTextHex = utils_1.convertBufferToHex(cipherText, true);\n    const unsigned = utils_1.concatBuffers(cipherText, iv);\n    const hmac = yield createHmac(unsigned, _key);\n    const hmacHex = utils_1.convertBufferToHex(hmac, true);\n    return {\n      data: cipherTextHex,\n      hmac: hmacHex,\n      iv: ivHex\n    };\n  });\n}\n\nexports.encrypt = encrypt;\n\nfunction decrypt(payload, key) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    const _key = utils_1.convertArrayBufferToBuffer(key);\n\n    if (!_key) {\n      throw new Error(\"Missing key: required for decryption\");\n    }\n\n    const verified = yield verifyHmac(payload, _key);\n\n    if (!verified) {\n      return null;\n    }\n\n    const cipherText = utils_1.convertHexToBuffer(payload.data);\n    const iv = utils_1.convertHexToBuffer(payload.iv);\n    const buffer = yield aesCbcDecrypt(cipherText, _key, iv);\n    const utf8 = utils_1.convertBufferToUtf8(buffer);\n    let data;\n\n    try {\n      data = JSON.parse(utf8);\n    } catch (error) {\n      return null;\n    }\n\n    return data;\n  });\n}\n\nexports.decrypt = decrypt;","map":{"version":3,"mappings":"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","names":["AES_ALGORITHM","HMAC_ALGORITHM","randomBytes","length","Promise","resolve","reject","crypto_1","error","result","exports","generateKey","_length","buffer","hex","utils_1","createHmac","data","key","hmac","update","digest","verifyHmac","payload","cipherText","iv","hmacHex","unsigned","chmac","chmacHex","aesCbcEncrypt","cipher","createCipheriv","final","aesCbcDecrypt","decipher","createDecipheriv","encrypt","providedIv","_key","ivArrayBuffer","ivHex","contentString","JSON","stringify","content","cipherTextHex","decrypt","Error","verified","utf8","parse"],"sources":["../../src/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}